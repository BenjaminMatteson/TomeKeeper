@page "/mytome"
@using TomeKeeper.Components
@using TomeKeeper.Enums
@using TomeKeeper.Models
@using TomeKeeper.ViewModels
@using TomeKeeper.Services
@rendermode InteractiveWebAssembly
@inject IAPIService _ApiService
@inject ITextFormatterService _TextFormatterService
@inject SavedSpellsService SavedSpellsService;
@inject SpellDetailsCacheService SpellDetailsCacheService;

<PageTitle>My Spellbook</PageTitle>

<div class="page-banner">
    <span class="tome-header-big">
        MY SPELLBOOK
    </span>
</div>

@if (_spellList.Any())
{
    <MudContainer MaxWidth=MaxWidth.ExtraLarge Class="pb-4">
        <MudAutocomplete T="SpellListItem"
                         Label="Search Spells"
                         Value="_selectedSpell"
                         ValueChanged="OnSpellSelected"
                         SearchFunc="@SearchSpells"
                         ToStringFunc="@(s => s?.Name)"
                         ResetValueOnEmptyText="true"
                         CoerceText="true"
                         Placeholder="Enter spell name..."
                         Variant="Variant.Outlined"
                         Adornment="Adornment.Start"
                         AdornmentIcon="@Icons.Material.Filled.Search"
                         Class="mb-4" />

        @foreach (var levelGroup in GetSpellsByLevel())
        {
            var isExpanded = IsLevelExpanded(levelGroup.Key);
            <div class="spell-level-section">
                <div class="spell-level-header" @onclick="@(() => ToggleLevelExpansion(levelGroup.Key))">
                    <div class="spell-level-header-content">
                        <span class="expand-icon">@(isExpanded ? "▼" : "▶")</span>
                        <h3>@GetLevelName(levelGroup.Key)</h3>
                    </div>
                    <span class="spell-count">@levelGroup.Count() spells</span>
                </div>
                @if (isExpanded)
                {
                    <div class="spell-list">
                    @foreach (var spell in levelGroup)
                    {
                        <div class="spell-list-item" @onclick="@(() => OnCardClick(spell))">
                            <div class="spell-list-main">
                                <div class="spell-list-name">@spell.Name</div>
                                <div class="spell-list-school">@spell.School</div>
                            </div>
                            <div class="spell-list-actions" @onclick:stopPropagation="true">
                                <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                               Color="Color.Error"
                                               Size="Size.Small"
                                               OnClick="@(() => RemoveFromSpellbook(spell))" />
                            </div>
                        </div>
                    }
                </div>
                }
            </div>
        }
    </MudContainer>

    @* Spell Details Modal Overlay *@
    @if (_showSpellDialog)
    {
        <div class="spell-modal-overlay" @onclick="CloseDialog">
            <div class="spell-modal-content" @onclick:stopPropagation="true">
                <MudPaper Elevation="8" Class="pa-6" Style="max-height: 80vh; overflow-y: auto; background-color: var(--parchment-medium); border: 3px solid var(--accent-gold);">
                    <div class="d-flex justify-space-between align-center mb-4">
                        <MudText Typo="Typo.h4" Style="font-family: 'Cinzel', serif; font-weight: 700; color: var(--primary-red-dark);">@_selectedSpellForDialog?.Name</MudText>
                        <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="CloseDialog" Color="Color.Default" />
                    </div>

                    @if (_selectedSpellDetails != null)
                    {
                        <div class="d-flex justify-space-between align-center mb-3">
                            <MudText Typo="Typo.body1" Color="Color.Secondary" Style="font-style: italic;">@GetSchoolLevelString(_selectedSpellDetails)</MudText>
                            @if (!string.IsNullOrEmpty(_selectedSpellDetails.Edition))
                            {
                                <MudChip T="string" Size="Size.Small" Color="@(_selectedSpellDetails.Edition == "2024" ? Color.Primary : Color.Secondary)" Style="font-weight: 600;">@_selectedSpellDetails.Edition</MudChip>
                            }
                        </div>
                        <MudDivider Class="my-3" />

                        <div class="spell-stats mb-3">
                            <MudText Typo="Typo.body1" Class="mb-2"><strong>Casting Time:</strong> @_selectedSpellDetails.CastingTime</MudText>
                            <MudText Typo="Typo.body1" Class="mb-2"><strong>Range:</strong> @_selectedSpellDetails.Range</MudText>
                            <MudText Typo="Typo.body1" Class="mb-2"><strong>Components:</strong> @GetComponentsString(_selectedSpellDetails)</MudText>
                            <MudText Typo="Typo.body1" Class="mb-2"><strong>Duration:</strong> @_selectedSpellDetails.Duration</MudText>
                        </div>

                        <MudDivider Class="my-4" />

                        @if (_selectedSpellDetails.Desc.Any())
                        {
                            <div class="spell-description">
                                @foreach (var desc in _selectedSpellDetails.Desc)
                                {
                                    var formattedDesc = _TextFormatterService.FormatBoldWords(System.Net.WebUtility.HtmlEncode(desc));
                                    <MudText Typo="Typo.body1" Class="mb-3">@((MarkupString)formattedDesc)</MudText>
                                }
                            </div>
                        }

                        @if (_selectedSpellDetails.HigherLevel != null && _selectedSpellDetails.HigherLevel.Any())
                        {
                            <MudDivider Class="my-4" />
                            <MudText Typo="Typo.h6" Style="font-weight: 700; color: var(--primary-red-dark);" Class="mb-2">At Higher Levels:</MudText>
                            @foreach (var higherLevel in _selectedSpellDetails.HigherLevel)
                            {
                                <MudText Typo="Typo.body1" Class="mb-2">@higherLevel</MudText>
                            }
                        }

                        <MudDivider Class="my-4" />
                        <div class="d-flex justify-end gap-2">
                            <MudButton OnClick="@(() => RemoveFromSpellbook(_selectedSpellForDialog))" Variant="Variant.Filled" Color="Color.Error">Remove from Spellbook</MudButton>
                            <MudButton OnClick="CloseDialog" Variant="Variant.Filled" Style="background-color: var(--primary-red-dark); color: white;">Close</MudButton>
                        </div>
                    }
                    else
                    {
                        <div class="d-flex justify-center align-center" style="min-height: 200px;">
                            <MudProgressCircular Indeterminate="true" Size="Size.Large" Color="Color.Primary" />
                        </div>
                    }
                </MudPaper>
            </div>
        </div>
    }

}
else
{
    <div class="empty-spellbook">
        <div class="empty-spellbook-icon">📜</div>
        <h2 class="empty-spellbook-title">Your Spellbook Awaits</h2>
        <p class="empty-spellbook-text">
            The pages of your tome are blank, young spellcaster.
        </p>
        <p class="empty-spellbook-text">
            Visit the <a href="/" class="mystical-link">Tome of All Spells</a> to begin your arcane collection.
        </p>
        <div class="empty-spellbook-runes">✦ ◆ ✦</div>
    </div>
}

@code {
    private IList<SpellListItem> _spellList = new List<SpellListItem>();
    private string _selectedSpellIndex { get; set; } = string.Empty;
    private SpellDetails? _selectedSpellDetails = null;
    private SpellDetailsViewModel _spellDetailsViewModel { get; set; } = new();
    private bool _isLoadingDetails { get; set; } = false;
    private bool _isInitialized = false;

    private IList<SpellListItem> _filteredSpellList = new List<SpellListItem>();
    private SpellListItem? _selectedSpell;

    // Dialog-related fields
    private bool _showSpellDialog = false;
    private SpellListItem? _selectedSpellForDialog;

    // Track expanded spell level sections (all expanded by default)
    private HashSet<short> _expandedLevels = new HashSet<short> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isInitialized)
        {
            _isInitialized = true;
            try
            {
                await SavedSpellsService.InitializeSavedSpellsAsync();
                _spellList = SavedSpellsService.SavedSpellListItems;
                _filteredSpellList = _spellList;
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading saved spells: {ex.Message}");
            }
        }
    }
    private async Task OnGetSpellDetailsClick(string spellIndex)
    {
        if (_selectedSpellIndex == spellIndex)
        {
            _selectedSpellIndex = string.Empty;
            _selectedSpellDetails = new();
        }
        else
        {
            try
            {
                _isLoadingDetails = true;
                await GetSpellDetailsViewModelFromIndex(spellIndex);
            }
            catch (HttpRequestException ex)
            {
                Console.WriteLine($"Error loading spell details: {ex.Message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Unexpected error loading spell details: {ex.Message}");
            }
            finally
            {
                _isLoadingDetails = false;
            }

        }
    }

    private void HandleRemoved(SpellListItem spell)
    {
        _spellList.Remove(spell);
        StateHasChanged();
    }

    #region Card and Dialog
    private async Task OnCardClick(SpellListItem spell)
    {
        _selectedSpellForDialog = spell;
        _selectedSpellDetails = null;
        _showSpellDialog = true;
        StateHasChanged();

        // Load spell details
        try
        {
            _selectedSpellDetails = await _ApiService.GetSpellDetails(spell.Index);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading spell details: {ex.Message}");
        }
    }

    private void CloseDialog()
    {
        _showSpellDialog = false;
        _selectedSpellForDialog = null;
        _selectedSpellDetails = null;
    }

    private async Task RemoveFromSpellbook(SpellListItem? spell)
    {
        if (spell == null) return;

        await SavedSpellsService.RemoveSpell(spell.Index);
        _spellList.Remove(spell);
        _filteredSpellList = _spellList;
        CloseDialog();
        StateHasChanged();
    }

    private string GetSchoolLevelString(SpellDetails spell)
    {
        var levelText = spell.Level == 0 ? "Cantrip" : $"Level {spell.Level}";
        var schoolName = spell.School?.Name ?? "Unknown";
        return $"{schoolName} - {levelText}";
    }

    private string GetComponentsString(SpellDetails spell)
    {
        var components = string.Join(", ", spell.Components ?? new List<string>());
        if (!string.IsNullOrEmpty(spell.Material))
        {
            components += $" ({spell.Material})";
        }
        return components;
    }
    #endregion

    private async Task GetSpellDetailsViewModelFromIndex(string spellIndex)
    {
        if (SpellDetailsCacheService.TryGetSpell(spellIndex, out var cachedSpell) && cachedSpell != null)
        {
            _spellDetailsViewModel = cachedSpell;
            _selectedSpellIndex = spellIndex;
            return;
        }

        _selectedSpellIndex = spellIndex;
        var spellDetails = await _ApiService.GetSpellDetails(spellIndex);
        _spellDetailsViewModel = new SpellDetailsViewModel(spellDetails);
        SpellDetailsCacheService.AddSpell(_spellDetailsViewModel);
    }

    #region Spell Search
    private Task<IEnumerable<SpellListItem>> SearchSpells(string value, CancellationToken cancellationToken)
    {
        if (string.IsNullOrEmpty(value))
            return Task.FromResult<IEnumerable<SpellListItem>>(_spellList);

        var results = _spellList.Where(x => x.Name.Contains(value, StringComparison.InvariantCultureIgnoreCase));
        return Task.FromResult<IEnumerable<SpellListItem>>(results);
    }

    private void OnSpellSelected(SpellListItem selected)
    {
        _selectedSpell = selected;

        if (selected == null)
        {
            _filteredSpellList = _spellList;
        }
        else
        {
            _filteredSpellList = _spellList.Where(x => x.Index == selected.Index).ToList();
        }

    }

    private IEnumerable<IGrouping<short, SpellListItem>> GetSpellsByLevel()
    {
        return _filteredSpellList
            .GroupBy(s => s.Level)
            .OrderBy(g => g.Key);
    }

    private string GetLevelName(short level)
    {
        return level == 0 ? "Cantrips" : $"Level {level} Spells";
    }

    private bool IsLevelExpanded(short level)
    {
        return _expandedLevels.Contains(level);
    }

    private void ToggleLevelExpansion(short level)
    {
        if (_expandedLevels.Contains(level))
        {
            _expandedLevels.Remove(level);
        }
        else
        {
            _expandedLevels.Add(level);
        }
    }
    #endregion
}
