@page "/mytome"
@using TomeKeeper.Components
@using TomeKeeper.Enums
@using TomeKeeper.Models
@using TomeKeeper.ViewModels
@using TomeKeeper.Services
@rendermode InteractiveWebAssembly
@inject IAPIService _ApiService
@inject ITextFormatterService _TextFormatterService
@inject SavedSpellsService SavedSpellsService;
@inject SpellDetailsCacheService SpellDetailsCacheService;

<PageTitle>My Spellbook</PageTitle>

<div class="page-banner">
    <span class="tome-header-big">
        MY SPELLBOOK
    </span>
</div>

@if (_spellList.Any())
{
    <MudContainer MaxWidth=MaxWidth.Large>
        <MudAutocomplete T="SpellListItem"
                         Label="Search Spells"
                         Value="_selectedSpell"
                         ValueChanged="OnSpellSelected"
                         SearchFunc="@SearchSpells"
                         ToStringFunc="@(s => s?.Name)"
                         ResetValueOnEmptyText="true"
                         CoerceText="true"
                         Placeholder="Enter spell name..."
                         Variant="Variant.Outlined"
                         Class="mb-4" />

        <MudExpansionPanels MultiExpansion="true">
            <Virtualize Items="@_filteredSpellList" Context="spell" ItemSize="48">
                <ItemContent>
                    <ExpandableScroll SpellListItem="spell"
                                      @key="spell.Index"
                                      ScrollMode="@ExpandableScrollMode.PersonalTome"
                                      OnRemoved="HandleRemoved" />
                </ItemContent>
            </Virtualize>
        </MudExpansionPanels>
    </MudContainer>

}
else
{
    <div class="empty-spellbook">
        <div class="empty-spellbook-icon">📜</div>
        <h2 class="empty-spellbook-title">Your Spellbook Awaits</h2>
        <p class="empty-spellbook-text">
            The pages of your tome are blank, young spellcaster.
        </p>
        <p class="empty-spellbook-text">
            Visit the <a href="/" class="mystical-link">Tome of All Spells</a> to begin your arcane collection.
        </p>
        <div class="empty-spellbook-runes">✦ ◆ ✦</div>
    </div>
}

@code {
    private IList<SpellListItem> _spellList = new List<SpellListItem>();
    private string _selectedSpellIndex { get; set; } = string.Empty;
    private SpellDetails _selectedSpellDetails { get; set; } = new();
    private SpellDetailsViewModel _spellDetailsViewModel { get; set; } = new();
    private bool _isLoadingDetails { get; set; } = false;

    private IList<SpellListItem> _filteredSpellList = new List<SpellListItem>();
    private SpellListItem? _selectedSpell;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await SavedSpellsService.InitializeSavedSpellsAsync();
            _spellList = SavedSpellsService.SavedSpellListItems;
            _filteredSpellList = _spellList;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading saved spells: {ex.Message}");
        }
    }
    private async Task OnGetSpellDetailsClick(string spellIndex)
    {
        if (_selectedSpellIndex == spellIndex)
        {
            _selectedSpellIndex = string.Empty;
            _selectedSpellDetails = new();
        }
        else
        {
            try
            {
                _isLoadingDetails = true;
                await GetSpellDetailsViewModelFromIndex(spellIndex);
            }
            catch (HttpRequestException ex)
            {
                Console.WriteLine($"Error loading spell details: {ex.Message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Unexpected error loading spell details: {ex.Message}");
            }
            finally
            {
                _isLoadingDetails = false;
            }

        }
    }

    private void HandleRemoved(SpellListItem spell)
    {
        _spellList.Remove(spell);
        StateHasChanged();
    }

    private async Task GetSpellDetailsViewModelFromIndex(string spellIndex)
    {
        if (SpellDetailsCacheService.TryGetSpell(spellIndex, out var cachedSpell) && cachedSpell != null)
        {
            _spellDetailsViewModel = cachedSpell;
            _selectedSpellIndex = spellIndex;
            return;
        }

        _selectedSpellIndex = spellIndex;
        var spellDetails = await _ApiService.GetSpellDetails(spellIndex);
        _spellDetailsViewModel = new SpellDetailsViewModel(spellDetails);
        SpellDetailsCacheService.AddSpell(_spellDetailsViewModel);
    }

    #region Spell Search
    private Task<IEnumerable<SpellListItem>> SearchSpells(string value, CancellationToken cancellationToken)
    {
        if (string.IsNullOrEmpty(value))
            return Task.FromResult<IEnumerable<SpellListItem>>(_spellList);

        var results = _spellList.Where(x => x.Name.Contains(value, StringComparison.InvariantCultureIgnoreCase));
        return Task.FromResult<IEnumerable<SpellListItem>>(results);
    }

    private void OnSpellSelected(SpellListItem selected)
    {
        _selectedSpell = selected;

        if (selected == null)
        {
            _filteredSpellList = _spellList;
        }
        else
        {
            _filteredSpellList = _spellList.Where(x => x.Index == selected.Index).ToList();
        }

    }
    #endregion
}
