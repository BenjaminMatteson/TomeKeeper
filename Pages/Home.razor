@page "/"
@using TomeKeeper.Components
@using TomeKeeper.Models
@using TomeKeeper.ViewModels
@using TomeKeeper.Services
@using TomeKeeper.Enums;
@rendermode InteractiveWebAssembly
@inject IAPIService _ApiService
@inject ITextFormatterService _TextFormatterService
@inject ISpellListItemsCacheService SpellListItemsCacheService;
@inject DragDropService DragDropService;
@inject SpellDetailsCacheService SpellDetailsCacheService;
@inject SavedSpellsService SavedSpellsService;

<PageTitle>All Spells</PageTitle>

<div class="page-banner">
    <span class="tome-header-big">
        TOME OF ALL SPELLS
    </span>
</div>

@if (SpellListItemsCacheService.CachedSpellList.Any())
{
    _spellList = SpellListItemsCacheService.CachedSpellList;
}

@if (_spellList.Any())
{
    <MudContainer MaxWidth=MaxWidth.Large>

        <MudAutocomplete T="SpellListItem"
                         Label="Search Spells"
                         Value="_selectedSpell"
                         ValueChanged="OnSpellSelected"
                         SearchFunc="@SearchSpells"
                         ToStringFunc="@(s => s?.Name)"
                         ResetValueOnEmptyText="true"
                         CoerceText="true"
                         Placeholder="Enter spell name..."
                         Variant="Variant.Outlined"
                         Class="mb-4" />
        <MudExpansionPanels MultiExpansion="true">
            <Virtualize Items="@_filteredSpellList" Context="spell" ItemSize="48">
                <ItemContent>
                    <ExpandableScroll SpellListItem="spell"
                                      ScrollMode="@ExpandableScrollMode.All" />

                </ItemContent>
            </Virtualize>
        </MudExpansionPanels>
    </MudContainer>

}
else
{
    <div class="scrying-container">
        <div class="crystal-orb">
            <div class="orb-glow"></div>
            <div class="orb-inner">
                <div class="magic-swirl"></div>
            </div>
            <div class="orb-reflection"></div>
        </div>
        <h2 class="scrying-title">Divining the Arcane...</h2>
        <p class="scrying-text">The ancient spells are being revealed</p>
        <div class="scrying-runes">
            <span class="rune">᛭</span>
            <span class="rune">ᚨ</span>
            <span class="rune">ᚱ</span>
            <span class="rune">ᚲ</span>
            <span class="rune">᛭</span>
        </div>
    </div>
}

@code {
    private IList<SpellListItem> _spellList = new List<SpellListItem>();
    private string _selectedSpellIndex { get; set; } = string.Empty;

    private IList<SpellListItem> _filteredSpellList = new List<SpellListItem>();
    private SpellListItem? _selectedSpell;

    private bool _isLoadingDetails { get; set; } = false;
    private bool _isActive { get; set; } = false;
    private bool _isInitialized = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isInitialized)
        {
            _isInitialized = true;
            try
            {
                if (!_spellList.Any())
                {
                    await RefreshSpellList();
                }

                _filteredSpellList = _spellList;

                await SavedSpellsService.InitializeSavedSpellsAsync();
                StateHasChanged();
            }
            catch (HttpRequestException ex)
            {
                Console.WriteLine($"Error loading spells: {ex.Message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Unexpected error during initialization: {ex.Message}");
            }
        }
    }

    #region Spell Loading
    //TODO: move to viewmodel
    private async Task OnRevealSpellsClick()
    {
        await RefreshSpellList();
        // Blazor automatically re-renders the component here, updating the UI
    }

    //TODO: move to viewmodel
    private async Task RefreshSpellList()
    {
        var spellList = await _ApiService.GetSpellsList();
        _spellList = spellList;
        SpellListItemsCacheService.CachedSpellList = spellList;
    }
    #endregion

    #region Spell Search
    private Task<IEnumerable<SpellListItem>> SearchSpells(string value, CancellationToken cancellationToken)
    {
        if (string.IsNullOrEmpty(value))
            return Task.FromResult<IEnumerable<SpellListItem>>(_spellList);

        var results = _spellList.Where(x => x.Name.Contains(value, StringComparison.InvariantCultureIgnoreCase));
        return Task.FromResult<IEnumerable<SpellListItem>>(results);
    }

    private void OnSpellSelected(SpellListItem selected)
    {
        _selectedSpell = selected;

        if (selected == null)
        {
            _filteredSpellList = _spellList;
        }
        else
        {
            _filteredSpellList = _spellList.Where(x => x.Index == selected.Index).ToList();
        }

    }
    #endregion

}